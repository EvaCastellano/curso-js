## Diferencias entre s√≠ncrono y as√≠ncrono
El c√≥digo s√≠ncrono se ejecuta linea a l√≠nea, espera cada l√≠nea que acabe para comenzar la siguiente.

```js
const p = document.querySelector('.parrafo');
p.textContent="Texto del p√°rrafo";
alert('¬°Texto modificado!');
p.style.backgroundColor='yellow';
```

La l√≠nea con el alert en el c√≥digo anterior bloquear√° el  c√≥digo, porque es s√≠ncrono.

setTimeout es as√≠ncrona y no bloquea el thread de ejecuci√≥n:

```js
const p = document.querySelector('.parrafo');
setTimeout(function () {
	p.textContent('Texto del p√°rrafo');
}, 5000);
p.style.backgroundColor='yellow';
```

```js
const img = document.querySelector('.fondo');
// la siguiente l√≠nea es as√≠ncrona
img.src='./bg.jpb';
// el callback se ejecutar√° cuando  se dispare  el  'load', que ser√° m√°s tarde que la √∫ltima l√≠nea de cambio de estilo
img.addEventListener('load', function () {
	img.classList.add('fadeIn');
});
p.style.backgroundColor='yellow';
```

Otros ejemplos de c√≥digo as√≠ncrono:
- API de geolocalizaci√≥n
- Llamadas  AJAX (*Asyncronous JavaScript And XML*)
	- XML era el formato habitual de intercambio
	- Ahora JSON es el formato  m√°s habitual, que es b√°sicamente  un objeto JavaScript convertido a string.

Vamos  con AJAX que es lo m√°s habitual. Hay  varias formas de hacer AJAX, empezaremos con la m√°s antigua:
```js
const request =  new XMLHttpRequest();
request.open(requestType, url); 
// requestType:  GET, POST...
request.send(); 
// data=request.send(); 
// error, data no  est√° ah√≠ todav√≠a, es  as√≠ncrono!
request.addEventListener('load', function() {
	console.log(this.responseText);
})

```


Vamos  a consumir  una API externa, consultamos el  repositorio de GitHub:  https://github.com/public-apis/public-apis
y  elegimos [REST Countries](https://restcountries.com/).

B√∫scamos los API Endpoints que son b√°sicamente las urls de los  datos. Si nos interesan datos por  pa√≠ses, la  url  ser√≠a:
```
https://restcountries.com/v3.1/name/{name}
```

>Tenemos que tener claras varias cosas con una  API  (rest)  que dejo fuera de esta  documentaci√≥n:
	Protocolo -> puerto asociado y consideraciones adicionales
	Nombre  de dominio -> DNS a IP Address
	Recurso
	
![[http-request.png]]	


Vamos  a  integrar todo en  una peque√±a app:

Fichero html:
```js
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="style.css" />
    <script defer src="script.js"></script>
    <title>Asynchronous JavaScript</title>
  </head>
  <body>
    <main class="container">
      <div class="countries">
        <!--
        <article class="country">
          <img class="country__img" src="" />
          <div class="country__data">
            <h3 class="country__name">COUNTRY</h3>
            <h4 class="country__region">REGION</h4>
            <p class="country__row"><span>üë´</span>POP people</p>
            <p class="country__row"><span>üó£Ô∏è</span>LANG</p>
            <p class="country__row"><span>üí∞</span>CUR</p>
          </div>
        </article>
        -->
      </div>
    </main>
  </body>
</html>
```

Fichero style.css:

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
}

html {
  font-size: 62.5%;
  box-sizing: border-box;
}

body {
  font-family: system-ui;
  color: #555;
  background-color: #f7f7f7;
  min-height: 100vh;

  display: flex;
  align-items: center;
  justify-content: center;
}

.container {
  display: flex;
  flex-flow: column;
  align-items: center;
}

.countries {
  /* margin-bottom: 8rem; */
  display: flex;

  font-size: 2rem;
  opacity: 0;
  transition: opacity 1s;
}

.country {
  background-color: #fff;
  box-shadow: 0 2rem 5rem 1rem rgba(0, 0, 0, 0.1);
  font-size: 1.8rem;
  width: 30rem;
  border-radius: 0.7rem;
  margin: 0 3rem;
  /* overflow: hidden; */
}

.neighbour::before {
  content: 'Neighbour country';
  width: 100%;
  position: absolute;
  top: -4rem;

  text-align: center;
  font-size: 1.8rem;
  font-weight: 600;
  text-transform: uppercase;
  color: #888;
}

.neighbour {
  transform: scale(0.8) translateY(1rem);
  margin-left: 0;
}

.country__img {
  width: 30rem;
  height: 17rem;
  object-fit: cover;
  background-color: #eee;
  border-top-left-radius: 0.7rem;
  border-top-right-radius: 0.7rem;
}

.country__data {
  padding: 2.5rem 3.75rem 3rem 3.75rem;
}

.country__name {
  font-size: 2.7rem;
  margin-bottom: 0.7rem;
}

.country__region {
  font-size: 1.4rem;
  margin-bottom: 2.5rem;
  text-transform: uppercase;
  color: #888;
}

.country__row:not(:last-child) {
  margin-bottom: 1rem;
}

.country__row span {
  display: inline-block;
  margin-right: 2rem;
  font-size: 2.4rem;
}

.btn-country {
  border: none;
  font-size: 2rem;
  padding: 2rem 5rem;
  border-radius: 0.7rem;
  color: white;
  background-color: orangered;
  cursor: pointer;
}

.images {
  display: flex;
}

.images img {
  display: block;
  width: 80rem;
  margin: 4rem;
}

.images img.parallel {
  width: 40rem;
  margin: 2rem;
  border: 3rem solid white;
  box-shadow: 0 2rem 5rem 1rem rgba(0, 0, 0, 0.1);
}


```


El c√≥digo JS  que tendr√≠amos que a√±adir ser√≠a  similar  al siguiente:

```js
'use strict';

const btn = document.querySelector('.btn-country');
const countriesContainer = document.querySelector('.countries');

///////////////////////////////////////

const getCountryData = function (country) {
  const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/${country}`);
  request.send();

  request.addEventListener('load', function () {
		// destructuring m√°s elegante que JSON.parse(this.responseText)[0]
    const [data] = JSON.parse(this.responseText);
    const name = data.name.common;
    const flag = data.flags.svg;
    const { region, population } = data;
    const language = Object.values(data.languages)[0];
    const currency = Object.values(data.currencies)[0].name;
    const html = `
    <article class="country">
      <img class="country__img" src="${flag}" />
      <div class="country__data">
        <h3 class="country__name">${name}</h3>
        <h4 class="country__region">${region}</h4>
        <p class="country__row"><span>üë´</span>${(population / 1000000).toFixed(
          1
        )} Million people</p>
        <p class="country__row"><span>üó£Ô∏è</span>${language}</p>
        <p class="country__row"><span>üí∞</span>${currency}</p>
      </div>
    </article>
    `;
    countriesContainer.insertAdjacentHTML('beforeend', html);
    countriesContainer.style.opacity = 1;
  });
};

getCountryData('spain');
getCountryData('portugal');
getCountryData('germany');
```

Comprueba que los datos vienen as√≠ncronos. No siempre aparecen los pa√≠ses en el mismo orden. Para conseguir esto habr√≠a que pedir los datos "en orden", cuando  acaba una request,  pedir la siguiente.

## Callback hell
Vamos a cambiar el ejercicio anterior, para que pinte no solo el pa√≠s sino  sus pa√≠ses vecinos utilizando la propiedad borders, que viene en la API.
Para ello hay que hacer 3 cosas:
- Refactorizar el c√≥digo y poner una funci√≥n  renderCountry que sea la encargada de pintar
- Si es un  pa√≠s vecino, al elemento  *article* le a√±adiremos  la clase *neighbour*
- Llamar a otro ENDPOINT para los  pa√≠ses  vecinos, ya que tenemos el c√≥digo del pa√≠s, no su nombre.

```js
'use strict';

const btn = document.querySelector('.btn-country');
const countriesContainer = document.querySelector('.countries');

///////////////////////////////////////

const renderCountry = function (data, className = '') {
  const name = data.name.common;
  const flag = data.flags.svg;
  const { region, population } = data;
  const language = Object.values(data.languages)[0];
  const currency = Object.values(data.currencies)[0].name;

  const html = `
  <article class="country ${className}">
    <img class="country__img" src="${flag}" />
    <div class="country__data">
      <h3 class="country__name">${name}</h3>
      <h4 class="country__region">${region}</h4>
      <p class="country__row"><span>üë´</span>${(population / 1000000).toFixed(
        1
      )} Million people</p>
      <p class="country__row"><span>üó£Ô∏è</span>${language}</p>
      <p class="country__row"><span>üí∞</span>${currency}</p>
    </div>
  </article>
  `;
  countriesContainer.insertAdjacentHTML('beforeend', html);
  countriesContainer.style.opacity = 1;
};

const getCountryAndNeighbour = function (country) {
  const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/${country}`);
  request.send();

  request.addEventListener('load', function () {
    const [data] = JSON.parse(this.responseText);
    renderCountry(data);
    for (const neighbour of data.borders) {
      // AJAX call country 2
      const request2 = new XMLHttpRequest();
      //restcountries.com/v3.1/alpha/
      https: request2.open(
        'GET',
        `https://restcountries.com/v3.1/alpha/${neighbour}`
      );
      request2.send();
      request2.addEventListener('load', function () {
        const [data] = JSON.parse(this.responseText);
        renderCountry(data, 'neighbour');
      });
    }
  });
};

getCountryAndNeighbour('spain');
```


Se producen al ejecutar varias  llamadas as√≠ncronas de forma secuencial. Imagina que quisieramos representar un pa√≠s, y  sus vecinos, pero luego los vecinos de este √∫ltimo....
Hace nuestro c√≥digo dif√≠cil de entender y mantener y por tanto  m√°s  susceptible a bugs.  Utilizaremos promises para  evitarlo.



## Promesas y la fetch API

Con las promesas  no dependemos de eventos y funciones de callback para obtener resultados de operaciones as√≠ncronas.  Las promesas se crearon  en ES6 (2015).
```js
  const request = new XMLHttpRequest();
  request.open('GET', `https://restcountries.com/v3.1/name/${country}`);
  request.send();
	request.addEventListener('load', function () {
		const [data] = JSON.parse(this.responseText);
		renderCountry(data);
	})
```

```js
  const request = fetch(`https://restcountries.com/v3.1/name/${country}`);
```


![[promises.png.png]]

```js
  const getCountryData = function(country){fetch(`https://restcountries.com/v3.1/name/${country}`)
	.then(response => response.json())
	.then(data=>renderCountry(data[0]))
};
getCountryData('spain');
```


.then puede recibir dos par√°metros, response y err, pero lo habitual es capturar los errores al final con un catch. Tambi√©n se puede usar un finally para poner una ejecuci√≥n al finalizar, por ejemplo parar la ejecuci√≥n de un spinner.
El  catch  se puede  provocar lanzando el getCountryData desde un bot√≥n  quitando la conexi√≥n a internet mediante las herramientas de desarrolllo.
Si  la respuesta  no est√°  bien (ejemplo un  404), se debe lanzar un error "a mano" porque por defecto no va al catch. Se pueden probar haciendo un getCountryData('adfadf').
```js
const getCountryData = function (country) {
  // Country 1
  fetch(`https://restcountries.com/v3.1/name/${country}`)
    .then(response => {
      console.log(response);
      if (!response.ok)
        throw new Error(`Country not found (${response.status})`);
      return response.json();
    })
    .then(data => {
      renderCountry(data[0]);
      // const neighbour = data[0].borders[0];
      const neighbour = 'dfsdfdef';
      if (!neighbour) return;
      // Country 2
      return fetch(`https://restcountries.com/v3.1/alpha/${neighbour}`);
    })
    .then(response => {
      if (!response.ok)
        throw new Error(`Country not found (${response.status})`);
      return response.json();
    })
    .then(data => {
      [data] = data;
      renderCountry(data, 'neighbour')
    })
    .catch(err => {
      console.error(`${err} üí•üí•üí•`);
      renderError(`Something went wrong üí•üí• ${err.message}. Try again!`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
};

getCountryAndNeighbour('spain');
```

¬°Ojo! La segunda llamada AJAX va con un return para poder seguir encadenando evitando callback hell.

Viendo el c√≥digo anterior se puede encapsular:
- La conversi√≥n a JSON
- El response.ok
- Y  aprovechamos para capturar el error de si un pa√≠s no tiene vecino (por ej. Australia)

```js

const getJSON = function (url, errorMsg = 'Something went wrong') {
  return fetch(url).then(response => {
    if (!response.ok) throw new Error(`${errorMsg} (${response.status})`);

    return response.json();
  });
};

const getCountryData = function (country) {
  // Country 1
  getJSON(
    `https://restcountries.eu/rest/v2/name/${country}`,
    'Country not found'
  )
    .then(data => {
      renderCountry(data[0]);
      const neighbour = data[0].borders[0];

      if (!neighbour) throw new Error('No neighbour found!');

      // Country 2
      return getJSON(
        `https://restcountries.eu/rest/v2/alpha/${neighbour}`,
        'Country not found'
      );
    })

    .then(data => renderCountry(data, 'neighbour'))
    .catch(err => {
      console.error(`${err} üí•üí•üí•`);
      renderError(`Something went wrong üí•üí• ${err.message}. Try again!`);
    })
    .finally(() => {
      countriesContainer.style.opacity = 1;
    });
};

btn.addEventListener('click', function () {
  getCountryData('portugal');
});```


## Desaf√≠o

Construye una funci√≥n  que pinte el pa√≠s en el  que est√°s en  la que est√°s en base a coordenadas GPS.

**PARTE 1**

1. Crea una  funci√≥n *whereami* que coja como entrada la longitud (lat) y la longitud(lng). Esto son coordenadas GPS, abajo de proporciono datos de ejemplo.

2. Haz  geolocalizaci√≥n inversa de las coordenadas. Geolocalizaci√≥n inversa significa convertir las coordenadas a una localidad y un pa√≠s. Usa esta API para conseguirlo: https://geocode.xyz/api. La llamada tendr√° el siguiente formato: https://geocode.xyz/52.508,13.381?geoit=json. Usa la fetch API y  promesas.

3. Muestra todos los datos recibidos por  consola. Usando estos datos escribe en consola un mensaje similar al siguiente: "Est√°s en Berlin, Germany".

4. Encadena un m√©todo catch a la cadena de promesas y muestra los errores por consola.

5. Esta API permite realizar 3 peticiones por segundo. Si recargas r√°pido la p√°gina obtendr√°s  un error 403. En estos casos fetch no hace un  reject de la promesa,  as√≠ que lanza un  error por tu  cuenta con  un  mensaje adecuado para que se muestre por consola.

**PARTE 2**

6. Usa los datos para mostrar el pa√≠s de las coordenadas introducidas. Utiliza la API de pa√≠ses que hemos visto  en  ejercicios anteriores.

7. Renderiza el pa√≠s como hemos visto anteriormente.

*TEST DE COORDENADAS 1: 52.508, 13.381 (Latitud, Longitud)*
*TEST DE COORDENADAS 2: 19.037, 72.873*
*TEST DE COORDENADAS 3: -33.933, 18.474*


## Event Loop
El event loop se encarga de orquestar el motor de JS, al tener un solo thread de ejecuci√≥n. Es la pieza esencial que permite el comportamiento as√≠ncrono en js, que haya concurrencia sin  bloqueos.
![[js-engine.png]]


Los registros as√≠ncronos se registran en la web API. Cuando se produce  un callback se manda a la callback queue,  desde donde se atienden en orden (event loop tick, cada vez que se vac√≠a la call stack). Tambi√©n hay una cola de microtareas relacionada con los callbacks de promesas, que tiene preferencia sobre  la call back queue.

![[event-loop.png]]

Observa las salidas de los siguientes c√≥digos  para ver si lo entiendes:

```js

console.log('Test start');

setTimeout(() => console.log('0 sec timer'), 0);

Promise.resolve('Resolved promise 1').then(res => console.log(res));

console.log('Test end');
```

```js
console.log('Test start');

setTimeout(() => console.log('0 sec timer'), 0);

Promise.resolve('Resolved promise 1').then(res => console.log(res));

Promise.resolve('Resolved promise 2').then(res => {
	for (let i = 0; i < 1000000000; i++) {}
	console.log(res);
});

console.log('Test end');```

## Construcci√≥n de promesas
La estructura es la siguiente:
```js
const lotteryPromise = new Promise (function (resolve, reject)  {

})
```

Ejemplo:
```js
const lotteryPromise = new Promise(function (resolve, reject) {
  console.log('Lotter draw is happening üîÆ');
	if (Math.random() >= 0.5) {
		resolve('You WIN üí∞');
	} else {
		reject(new Error('You lost your money üí©'));
	}
});

lotteryPromise.then(res => console.log(res)).catch(err => console.error(err));
```

Lo suyo es que dentro hubiera algo as√≠ncrono, por ej. utilizando la funci√≥n setTimeOut:
```js
const lotteryPromise = new Promise(function (resolve, reject) {
  console.log('Lottery draw is happening üîÆ');
  setTimeout(function () {
    if (Math.random() >= 0.5) {
      resolve('You WIN üí∞');
    } else {
      reject(new Error('You lost your money üí©'));
    }
  }, 2000);
});

lotteryPromise.then(res => console.log(res)).catch(err => console.error(err));
```

Convertir algo en promesas  es lo que se  llama **Promisify**. Por ejemplo vamos a hacer un promisify de este callback hell:
```js
setTimeout(() => {
  console.log('1 second passed');
  setTimeout(() => {
    console.log('2 seconds passed');
    setTimeout(() => {
      console.log('3 second passed');
      setTimeout(() => {
        console.log('4 second passed');
      }, 1000);
    }, 1000);
  }, 1000);
}, 1000);
```


```js
// Promisifying setTimeout
const wait = function (seconds) {
  return new Promise(function (resolve) {
    setTimeout(resolve, seconds * 1000);
  });
};

wait(1)
  .then(() => {
    console.log('1 second passed');
    return wait(1);
  })
  .then(() => {
    console.log('2 second passed');
    return wait(1);
  })
  .then(() => {
    console.log('3 second passed');
    return wait(1);
  })
  .then(() => console.log('4 second passed'));
```
Existe la opci√≥n de utilizar funciones *async-await* para escribirlo de forma s√≠ncrona:

```js
const waitProcess = async function () {
	await wait(1)
	console.log('1 second passed**')
	await wait(5)
	console.log('5 second passed**')
	await wait(3)
	console.log('3 second passed**')
}
```
